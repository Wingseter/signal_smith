"""
Strategy Base Class and Interfaces for Backtesting
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

import pandas as pd


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    signal_type: SignalType
    symbol: str
    price: float
    timestamp: datetime
    strength: float = 1.0  # 0.0 to 1.0
    reason: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Position:
    """Current position in a stock."""
    symbol: str
    quantity: int
    entry_price: float
    entry_date: datetime
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    unrealized_pnl_pct: float = 0.0

    def update_price(self, price: float) -> None:
        """Update current price and calculate unrealized P&L."""
        self.current_price = price
        self.unrealized_pnl = (price - self.entry_price) * self.quantity
        self.unrealized_pnl_pct = ((price - self.entry_price) / self.entry_price) * 100


@dataclass
class Trade:
    """Completed trade record."""
    symbol: str
    entry_date: datetime
    entry_price: float
    exit_date: datetime
    exit_price: float
    quantity: int
    side: str  # "long" or "short"
    pnl: float = 0.0
    pnl_pct: float = 0.0
    commission: float = 0.0
    slippage: float = 0.0
    holding_days: int = 0
    exit_reason: str = ""

    def __post_init__(self):
        self.pnl = (self.exit_price - self.entry_price) * self.quantity - self.commission - self.slippage
        self.pnl_pct = ((self.exit_price - self.entry_price) / self.entry_price) * 100
        self.holding_days = (self.exit_date - self.entry_date).days


@dataclass
class StrategyContext:
    """Context provided to strategy for decision making."""
    symbol: str
    current_date: datetime
    current_price: float
    ohlcv: pd.DataFrame  # Historical OHLCV data up to current_date
    position: Optional[Position]
    cash: float
    portfolio_value: float
    parameters: Dict[str, Any] = field(default_factory=dict)


class Strategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, name: str, description: str = "", **parameters):
        self.name = name
        self.description = description
        self.parameters = parameters

    @abstractmethod
    def generate_signal(self, context: StrategyContext) -> Signal:
        """
        Generate a trading signal based on the current context.

        Args:
            context: StrategyContext with market data and portfolio state

        Returns:
            Signal indicating buy, sell, or hold
        """
        pass

    def calculate_position_size(
        self,
        context: StrategyContext,
        signal: Signal,
        max_position_pct: float = 0.1,
    ) -> int:
        """
        Calculate the position size for a trade.

        Args:
            context: Current strategy context
            signal: Generated signal
            max_position_pct: Maximum percentage of portfolio for single position

        Returns:
            Number of shares to trade
        """
        if signal.signal_type == SignalType.HOLD:
            return 0

        if signal.signal_type == SignalType.SELL:
            # Sell entire position
            return context.position.quantity if context.position else 0

        # Buy signal - calculate based on signal strength and portfolio
        available_cash = context.cash * max_position_pct * signal.strength
        shares = int(available_cash / context.current_price)
        return max(0, shares)

    def validate_parameters(self) -> bool:
        """Validate strategy parameters. Override in subclasses."""
        return True

    def get_required_history(self) -> int:
        """Return minimum number of bars required for this strategy."""
        return 50

    def to_dict(self) -> Dict[str, Any]:
        """Convert strategy to dictionary representation."""
        return {
            "name": self.name,
            "description": self.description,
            "parameters": self.parameters,
            "required_history": self.get_required_history(),
        }

    def __repr__(self) -> str:
        params = ", ".join(f"{k}={v}" for k, v in self.parameters.items())
        return f"{self.__class__.__name__}({params})"
